class PoliceCentral is subclass of GLOBAL

values

instance variables

public io : IO := new IO();
-- links to Patroles and locations
public patroleLocations : map nat to Coordinates := {|->};
public patroles         : map nat to Patrole := {|->};
inv dom patroleLocations = dom patroles;
    
-- Store the tasks arriving from the environment
tasks : seq of Task := [];
-- Status of the instantiated class
busy : bool := false;

functions

operations
    
-- Operation that add a new patrole. Used by class World
public addPatrole: Patrole ==> ()
addPatrole(pPatrole) ==
(   
    dcl pId : nat := card dom patroles + 1;
    atomic
    (patroleLocations := patroleLocations munion {pId |-> pPatrole.get_location()};
     patroles := patroles munion {pId |-> pPatrole})
);
        
    -- Operation that add a multiple new patroles. Used by class World
public addMultiplePatroles: set of Patrole ==> ()
addMultiplePatroles(sPatrole) ==  
(
    for all p in set sPatrole do
    (dcl pId : nat := card dom patroles + 1;
     atomic
     (patroleLocations := patroleLocations munion {pId |-> p.get_location()};
      patroles := patroles munion {pId |-> p})
    );
);


public Step: () ==> ()
Step() ==
(
    if tasks <> []
    then
        let curTask = getTask(),
            ids : set of ID = dom patroles,
            id = closestPatrole(ids, curTask.t_type, curTask.t_loc)
        in
        (
            printTask(curTask);
            if id <> nil
            then
            (  
                dcl dist : real := distToTask(patroles(id).get_location(), curTask.t_loc);
                patroles(id).addTask(curTask, dist);
            )
            else
            (   
                io.print("!!!NO AVAILABLE PATROLE FOR TASK!!!\n\n");
                World`env.handleTask(curTask, nil, nil, nil);
            );  
        );         
    busy := len tasks > 0;
            
    printPatroleStatus();
    for all id in set dom patroles do 
        patroles(id).Step()
);

    
public closestPatrole: set of ID * TaskType * Coordinates ==> [ID]
closestPatrole(pIds, pTaskType, pTaskCoord) ==
(   
    dcl ids : set of ID := pIds;
    while ids <> {} do
    (
        let
            -- Finds the closest patrole in temporary patroleDB
            id1 in set ids be st forall id2 in set ids
            & distToTask(patroleLocations(id1), pTaskCoord) <= distToTask(patroleLocations(id2), pTaskCoord)
        in
            if 
                taskPriority(pTaskType) > patroles(id1).get_currentPriority() and 
                patrolePriority(patroles(id1).get_patroleType()) >= taskPriority(pTaskType)
            then
                return id1
            else
                -- Remove the closest patrole from temporary patroleDB (not suitable for task) 
                ids := ids \ {id1}
    );
    return nil
)
pre pIds <> {};
     
-- Operation that returns the distance between a patrole and a task
public distToTask: Coordinates * Coordinates ==> real
distToTask(patroleLocs, pTaskCoord) ==
(let
    r : real = (patroleLocs.x - pTaskCoord.x)**2 + (patroleLocs.y - pTaskCoord.y)**2,
    res : real = sqrt(r, 0.005) 
 in
    return res
);

-- Operation to approximate the square root of real number with error, e.
-- From book, VDM-10 Language Manual (p. 123) 
private sqrt: real * real ==> real
sqrt(r,e) ==
(
    if r = 0
    then return 0
    else 
    (
        dcl x: real := 1,
        nextx: real := r;
        while abs(x-nextx) >= e * r  do
        (
            x := nextx;
            nextx := ((r / x) + x) / 2;
        );
        return nextx
    )
)
    pre r >= 0;

/* public addTask: ID * Coordinates * TaskType * Time * Time ==> ()
addTask(pId, pCoord, pTaskType, pTime, pTaskDuration) ==
(
    tasks := tasks ^ [mk_Task(pId, pCoord, pTaskType, pTime, pTaskDuration)];
    busy := true
); */
public addTask: Task ==> ()
addTask(pTask) ==
    (tasks := tasks ^ [pTask];
     busy := true);

private getTask: () ==> Task
getTask() ==
    (dcl res : Task := hd tasks;
     tasks := tl tasks;
     return res);

public isFinished: () ==> bool
isFinished () ==
    return forall id in set dom patroles & patroles(id).isFinished();

------------------------------------------------
-- Operations for printing out result
------------------------------------------------
    printPatroleStatus: () ==> ()
    printPatroleStatus() ==
    (
        io.print("STATUS\n");     
        io.printf("Time  %s:\tPatroleType\tLoc\tPrio\tTask\tTask Done\n", [World`timerRef.GetTime()]);
        io.print("------------------------------------------------------------------\n");
        for all id in set dom patroles do
        (
            dcl task : [Task] := patroles(id).get_curTask();
            io.printf("Patrole %s:\t", [id]);
            io.printf("%s\t", [patroles(id).get_patroleType()]); 
            io.printf("(%s,%s)\t", [patroles(id).get_location().x, patroles(id).get_location().y]);
            io.printf("%s\t", [patroles(id).get_currentPriority()]); 
            if task = nil
            then 
            (    
                io.print(task);io.print("\t");io.print(task);io.print("\n")
            )
            else io.printf("%s\t%s\n", [task.t_type, task.t_duration+World`timerRef.GetTime()]);
        );
        io.print("------------------------------------------------------------------\n\n");
    );

    printTask: Task ==> ()
    printTask(pTask) ==
        ( 
            io.print("#################################################\n");
            io.printf("%s received at time: %s, location: (%s,%s)\n", [pTask.t_type, pTask.t_time, pTask.t_loc.x, pTask.t_loc.y]);
            io.print("#################################################\n\n");
        );

end PoliceCentral