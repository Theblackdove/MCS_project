class PoliceCentral is subclass of Global

values

instance variables
    
    -- links to Patroles
    patroleLocations : map nat to Coordinates := {|->};
    patroles         : map nat to Patrole := {|->};
    inv dom patroleLocations = dom patroles;
    
    -- Store the tasks arriving from the environment
    tasks : seq of (ID * Coordinates * TaskType * Time * Time) := [];

    curTask : [Task] := nil; 
    
    -- Status of the instantiated class
    busy : bool := false;

functions

operations
    
    -- Operation that add a new patrole. Used by class World
    public addPatrole: Patrole ==> ()
    addPatrole(pPatrole) ==
        (   
            dcl pId : nat := card dom patroles + 1;
            atomic
            (
                patroleLocations := patroleLocations munion {pId |-> pPatrole.get_location()};
                patroles := patroles munion {pId |-> pPatrole};  
            )
        );
        
    -- Operation that add a multiple new patroles. Used by class World
    public addMultiplePatroles: set of Patrole ==> ()
    addMultiplePatroles(sPatrole) ==
        (   
            for all p in set sPatrole do
            (    
                dcl pId : nat := card dom patroles + 1;
                atomic
                (
                    patroleLocations := patroleLocations munion {pId |-> p.get_location()};
                    patroles := patroles munion {pId |-> p};   
                )
            );
        );

    public Step: () ==> ()
    Step() ==
        (
            if 
                tasks <> []
            then
                let
                    -- Load in task
                    mk_(taskId, pTaskCoord, pTaskType, pTime, pTaskDuration) = getTask(),
                    -- Finds the id of the closest patrole in PatroleDB. 
                    id = closestPatrole(patroleLocations, pTaskType, pTaskCoord)  
                in
                (
                    if
                        id <> nil
                    then
                    (   
                        -- Calculate distance from patrole to task 
                        dcl dist : real := distToTask(patroles(id).get_location(), pTaskCoord);
                        -- Add task to given patrole
                        patroles(id).addTask(taskId, pTaskCoord, pTaskType, dist, pTime, pTaskDuration);
                    )
                    else
                    (   
                        -- No Available patroles found 
                        World`env.handleTask(taskId, nil, nil, pTaskType, pTaskCoord, nil, pTime);
                        World`env.io.print("No vacant Patroles\n")    
                    )  
                );         
            busy := len tasks > 0;
            
            for all id in set dom patroles do 
                patroles(id).Step()
        );
    
    private closestPatrole: map nat to Coordinates * TaskType * Coordinates ==> [ID]
    closestPatrole(patroleLocs, pTaskType, pTaskCoord) ==
        (   
            dcl ids : set of nat := dom patroleLocs;
            while ids <> {} do
            (
                let
                    -- Finds the closest patrole in temporary patroleDB
                    c1 in set ids be st forall c2 in set ids
                    & distToTask(patroleLocs(c1), pTaskCoord) <= distToTask(patroleLocs(c2), pTaskCoord)
                in
                    if 
                        taskPriority(pTaskType) > patroles(c1).get_currentPriority() and 
                        patrolePriority(patroles(c1).get_patroleType()) >= taskPriority(pTaskType)
                    then
                        return c1
                    else
                        -- Remove the closest patrole from temporary patroleDB (not suitable for task) 
                        ids := ids \ {c1}
            );
            return nil
        )
    pre patroleLocs <> {|->}
    post RESULT in set dom patroles or RESULT = nil; -- Possibly redundant??  
     -- Operation that finds the closest patrole wrt. a given task.
    /* private closestPatrole: map nat to Patrole * TaskType * Coordinates ==> [ID]
    closestPatrole(sPatroles, pTaskType, pTaskCoord) ==
        (   
            dcl temp : set of nat := dom sPatroles;
            while temp <> {} do
            (
                let
                    -- Finds the closest patrole in temporary patroleDB
                    id1 in set temp be st forall id2 in set temp
                    & distToTask(sPatroles(id1).get_location(), pTaskCoord) <= distToTask(sPatroles(id2).get_location(), pTaskCoord)
                in
                    if 
                        taskPriority(pTaskType) > sPatroles(id1).get_currentPriority() and 
                        patrolePriority(sPatroles(id1).get_patroleType()) >= taskPriority(pTaskType)
                    then
                        return id1
                    else
                        -- Remove the closest patrole from temporary patroleDB (not suitable for task) 
                        temp := temp \ {id1}
            );
            return nil
        )
    pre sPatroles <> {|->}
    post RESULT in set dom patroles or RESULT = nil; -- Possibly redundant??  */
     
    -- Operation that returns the distance between a patrole and a task
    private distToTask: Coordinates * Coordinates ==> real
    distToTask(patroleLocs, pTaskCoord) ==
        (
            let
                r : real = (patroleLocs.x - pTaskCoord.x)**2 + (patroleLocs.y - pTaskCoord.y)**2,
                res : real = sqrt(r, 0.005) 
            in
                return res
        );

    -- Operation to approximate the square root of real number with error, e.
    -- From book, VDM-10 Language Manual (p. 123) 
    private sqrt: real * real ==> real
    sqrt(r,e) ==
        (
            if r = 0
            then return 0
            else 
            (
                dcl x: real := 1,
                nextx: real := r;
                while abs(x-nextx) >= e * r  do
                    (
                        x := nextx;
                        nextx := ((r / x) + x) / 2;
                    );
                return nextx
            )
        )
    pre r >= 0;

    public addTask:  ID * Coordinates * TaskType * Time * Time ==> ()
    addTask (pId, pCoord, pTaskType, pTime, pTaskDuration) == 
        (
            tasks := tasks ^ [mk_(pId, pCoord, pTaskType, pTime, pTaskDuration)];
            busy := true
        );
    
    private getTask: () ==> ID * Coordinates * TaskType * Time * Time
    getTask() ==
        (
            dcl res : ID * Coordinates * TaskType * Time * Time := hd tasks;
            tasks := tl tasks;
            return res
        );

    public isFinished: () ==> bool
    isFinished () ==
        return forall id in set dom patroles &
            patroles(id).isFinished();


    private printStatus: Task * Patrole ==> ()
    printStatus(pTask, pPatrole) ==
        is not yet specified
end PoliceCentral